Άσκηση 6. (Επαναλαμβανόμενος τετραγωνισμός – έλεγχοι πρώτων αριθμών)
(α) Γράψτε πρόγραμμα σε γλώσσα της επιλογής σας (θα πρέπει να υποστηρίζει πράξεις με αριθμούς
100δων ψηφίων) που να ελέγχει αν ένας αριθμός είναι πρώτος με τον έλεγχο (test) του Fermat:
Αν n πρώτος τότε για κάθε a τ.ώ. 1 < a < n − 1, ισχύει
a
n−1 mod n = 1
Αν λοιπόν, για δεδομένο n βρεθεί a ώστε να μην ισχύει η παραπάνω ισότητα τότε ο αριθμός n είναι
οπωσδήποτε σύνθετος. Αν η ισότητα ισχύει για το συγκεκριμένο a, τότε η δοκιμή πρέπει να επαναληφθεί με νέο a, καθώς υπάρχει περίπτωση ο αριθμός να είναι σύνθετος και παρ’όλα αυτά η ισότητα
να ισχύει για κάποιες τιμές του a. Μια ενδιαφέρουσα ιδιότητα λέει ότι, αν ο n είναι σύνθετος, η πιθανότητα να ισχύει η ισότητα είναι ≤ 1/2 (αυτό ισχύει για όλα τα n εκτός από κάποιες ‘παθολογικές’
2
περιπτώσεις, που λέγονται αριθμοί Carmichael, δείτε ερώτημα (β) παρακάτω). Έτσι, μπορούμε να αυξήσουμε σημαντικά την πιθανότητα επιτυχίας (δηλ. της επιβεβαίωσης της συνθετότητας του αριθμού
n) επαναλαμβάνοντας μερικές φορές τη δοκιμή (τυπικά 30 φορές) με διαφορετικό a. Αν όλες τις φορές βρεθεί να ισχύει η παραπάνω ισότητα τότε λέμε ότι το n “περνάει το test” και ανακηρύσσουμε το
n πρώτο αριθμό· αν έστω και μία φορά αποτύχει ο έλεγχος, τότε είμαστε βέβαιοι ότι ο αριθμός είναι
σύνθετος.
Το πρόγραμμά σας θα πρέπει να δουλεύει σωστά για αριθμούς χιλιάδων ψηφίων. Δοκιμάστε την με
τους αριθμούς:
67280421310721, 170141183460469231731687303715884105721, 2
2281 − 1
Σημείωση: το a
2
2281−2
έχει ‘αστρονομικά’ μεγάλο πλήθος ψηφίων (δεν χωράει να γραφτεί ούτε σε
ολόκληρο το σύμπαν!), ενώ το a
2
2281−2 mod (22281 − 1) είναι σχετικά “μικρό” (έχει μερικές χιλιάδες
δεκαδικά ψηφία μόνο :-) ) οπότε είναι δυνατόν να το υπολογίσουμε (με λίγη προσοχή).
(β) Υπάρχουν (λίγοι) σύνθετοι που έχουν την ιδιότητα να περνούν τον έλεγχο Fermat για κάθε a που
είναι σχετικά πρώτο με το n, οπότε για αυτούς το test θα αποτύχει όσες δοκιμές και αν γίνουν (εκτός
αν πετύχουμε κατά τύχη a που δεν είναι σχετικά πρώτο με το n, πράγμα αρκετά απίθανο για αρκετά
μεγάλο n). Αυτοί οι αριθμοί λέγονται Carmichael – δείτε και http://en.wikipedia.org/wiki/
Carmichael_number. Ελέγξτε τη συνάρτησή σας με αρκετά μεγάλους αριθμούς Carmichael που θα
βρείτε π.χ. στη σελίδα
http://de.wikibooks.org/wiki/Pseudoprimzahlen:_Tabelle_Carmichael-Zahlen. Τι παρατηρείτε;
(γ) Mελετήστε και υλοποιήστε τον έλεγχο Miller-Rabin (π.χ. από τις σημειώσεις που θα βρείτε στη
σελίδα του μαθήματος στο Helios) που αποτελεί βελτίωση του ελέγχου του Fermat και δίνει σωστή απάντηση με πιθανότητα τουλάχιστον 1/2 για κάθε φυσικό αριθμό (οπότε με 30 επαναλήψεις
έχουμε αμελητέα πιθανότητα λάθους για κάθε αριθμό εισόδου). Δοκιμάστε τον με διάφορους αριθμούς Carmichael. Βλέπετε κάτι περίεργο; Πώς το εξηγείτε;
(γ) Γράψτε πρόγραμμα που να βρίσκει όλους τους πρώτους αριθμούς Mersenne, δηλαδή της μορφής
n = 2x − 1 με 1 < x < 200 (σημειώστε ότι αν το x δεν είναι πρώτος, ούτε το 2
x − 1 είναι πρώτος –
μπορείτε να το αποδείξετε;). Αντιπαραβάλετε με όσα αναφέρονται στην ιστοσελίδα https://www.
mersenne.org/primes/.
Άσκηση 7. (Αριθμοί Fibonacci)
(α) Υλοποιήστε και συγκρίνετε τους εξής αλγορίθμους για υπολογισμό του n-οστού αριθμού Fibonacci:
αναδρομικό με memoization, επαναληπτικό, και τον αλγόριθμο με χρήση πινάκων 2 × 2.
Υλοποιήστε τους αλγορίθμους σε γλώσσα που να υποστηρίζει πολύ μεγάλους ακεραίους (100δων
ψηφίων), π.χ. σε Python. Χρησιμοποιήστε τον πολλαπλασιασμό ακεραίων που παρέχει η γλώσσα. Τι
συμπεραίνετε;
(β) Δοκιμάστε να λύσετε το παραπάνω πρόβλημα με ύψωση σε δύναμη, χρησιμοποιώντας τη σχέση
του Fn με το ϕ (χρυσή τομή). Τι παρατηρείτε;
(γ) Υλοποιήστε συνάρτηση, όσο το δυνατόν πιο αποδοτική, που να δέχεται σαν είσοδο δύο θετικούς
ακεραίους n, k και να υπολογίζει τα k λιγότερο σημαντικά ψηφία του n-οστού αριθμού Fibonacci.
Θεωρώντας n = 10i
, k = 17 βρείτε το μεγαλύτερο i για το οποίο η συνάρτησή σας δίνει σωστό
αποτέλεσμα εντός χρόνου 1 sec.
3
(δ) Αναζητήστε και εξετάστε τη μέθοδο Fast Doubling για να επιλύσετε το ερώτημα (γ). Συγκρίνετέ
την με τη μέθοδο χρήσης πινάκων 2 × 2 θεωρητικά και υπολογιστικά.
Άσκηση 8. (Αλγόριθμοι Διαίρει και Βασίλευε)
[άσκηση από το βιβλίο Algorithms, των Dasgupta, Papadimitriou, Vazirani]
Μία ακολουθία στοιχείων A[1], . . . , A[n] λέμε ότι έχει ένα πλειοψηφούν στοιχείο (majority element)
αν περισσότερα από τα μισά στοιχεία της ακολουθίας είναι ίδια. Με δεδομένη μια ακολουθία, ο σκοπός είναι να σχεδιαστεί ένας αποδοτικός αλγόριθμος ο οποίος να προσδιορίζει αν η ακολουθία έχει
πλειοψηφούν στοιχείο, και αν ναι να βρίσκει αυτό το στοιχείο. Τα στοιχεία της ακολουθίας δεν προέρχονται υποχρεωτικά από κάποιο διατεταγμένο πεδίο τιμών όπως οι ακέραιοι, και έτσι δεν μπορούν
να υπάρχουν συγκρίσεις της μορφής “ισχύει A[i] > A[j];”. (Για παράδειγμα μπορείτε να θεωρήσετε
τα στοιχεία της ακολουθίας είναι αρχεία GIF). Ωστόσο μπορείτε να απαντάτε σε σταθερό χρόνο σε
ερωτήσεις της μορφής: “ισχύει A[i] = A[j];”.
1. Δείξτε πως θα λύσετε αυτό το πρόβλημα σε χρόνο O(n log n). (Υπόδειξη: Χωρίστε τη ακολουθία A σε δύο ακολουθίες A1 και A2 με το μισό μέγεθος. Η γνώση των πλειοψηφούντων
στοιχείων των A1 και A2 σας βοηθά να βρείτε το πλειοψηφούν στοιχείο του A; (Αν ναι, μπορείτε να χρησιμοποιήσετε μία προσέγγιση ‘διαίρει και βασίλευε’.)
2. Μπορείτε να βρείτε έναν αλγόριθμο γραμμικού χρόνου;
(Υπόδειξη: σκεφτείτε την παρακάτω προσέγγιση ‘διαίρει και βασίλευε’:
• Συνδυάστε τα στοιχεία του A με αυθαίρετο τρόπο, για να δημιουργήσετε n/2 ζεύγη.
• Εξετάστε κάθε ζεύγος: αν τα δύο στοιχεία είναι διαφορετικά, απορρίψτε τα και τα δύο. Αν
είναι ίδια, διατηρήστε μόνο το ένα από αυτά.
Δείξτε ότι μετά από αυτή τη διαδικασία έχουν απομείνει το πολύ n/2 στοιχεία, και ότι
έχουν ένα πλειοψηφούν στοιχείο σε περίπτωση που η ακολουθία A έχει τέτοιο στοιχείο.)